----
1、11、20、21、23、202、206、226、20
----
4、28(kmp)
----
total:31
----

2 Add two numbers,两数相加
    (2 -> 4 -> 3) + (5 -> 6 -> 4)：写了递归和非递归两种，再看下非递归的写法

3 Longest Substring Without Repeating Characters，无重复字符的最长子串
    维持一个left~index之间没有重复的区间，通过map判断是否有重复字符，搞清楚不断更新left的逻辑。

5 Longest Palindromic Substring 最长回文子串
    #1笨方法：中心扩展，暴力的去试aba和abba这两种情况
    2矩阵判断回文，不过1和2时间复杂度都是n2
    ##3Manacher没看

6 ZigZag Conversion Z 字形变换
    #就是一个字符串字符向下向上摆成N字型，最后从第一行输出。
    一个一个走，用方向判断向上向下。
    还有一种是找行与行之间元素的规律。

7 Math，把一个数反转输出，123，321， 120→21，负数要保留，如果越界出现，那么要return 0
    首先思路是用个long型，如果越界，返回0，但是题目中说处于一个没法用32位以上的环境
    #那么就要想想怎么只用int判断越界了，那就是 temp=result*10 + x%10 ，这个结果，然后反过来temp/10再跟result对比一下，不一样则越界\

8 String to Integer 字符变数字
    看一看吧，感觉没什么意义

9 Palindrome Number 判断一个数是否是回文数，常识：负数肯定不是回文数
    #跟数的反转差不多的意思，原数x除以10，然后临时变量不断乘以10，直到临时变量不小于x了，
    那么如果他们相等或者是除以10之后相等，那么就是回文

12 Integer to Roman 整数转罗马数字  字符和数字的转换，这里用hash的方式记录字符和数字的关系
13 Roman to Integer 上边反过来 IV对应4，

14 String 求string数组中的公共前缀
    写错了一遍，整体思路是先拿第一个值，然后往后遍历，后边的值indexof它不为0，那么就要把它减掉最后一个char
    复习了string的substring函数，然后就是由于result是不断削减的，所以要把他放到indexof的括号里边去
    ##可以再去看看题解里的其他方法

15 3Sum
16 3Sum Closest 这两个题目思路基本一样，先排序，然后两层循环，第一层定位index，下一层左右两个指针向中间逼近
18 4Sum 思路相同，12345，可以固定两个指针12，然后在3，5设置left和right，时间复杂度n3
 
17 排列组合 递归
    #2-9对应小键盘的字母，输出所有的可能，就是用递归来做

19 list 删除倒数第N个节点
    #记住，使用2个节点的方法，首先创造一个前驱节点，用两个指针指向前驱，删除倒数第2个，那么让first先走3步，之后一起走，知道first==null

22 排列组合 递归
    #生成n个括号可能的组合

24 list 两两交换节点，1234→2143
    ##递归和非递归写法

25 list 每K个翻转链表，hard难度，改了好久可算是自己写出来了
    #这种链表的题目，经常再前边价格dummy伪节点

26 
27 一个类型，简单看下就好

31 数组的下一个排列 1234→1243 1243→1324 4321→1234
    从后边开始找到第一个出现nums[i-1]>nums[i]的情况，然后把i-1和后边的第一次大于nums[i-1]的数交换
    然后逆序i到最后一个位置

32 字符串一堆（），判断最长的有些长度
    #第一种方法时动态规划，注意两种情况的判断和越界判断
    #第二种方法借助栈
    ##最后一个空间复杂度为1的方法
















