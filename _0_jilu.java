package LeetCode;

import java.util.*;

public class _0_jilu {

    public static void main(String[] args) {
       System.out.println((int) 'a');
       System.out.println("abc".indexOf(""));
    }

    

    /*LeetCode*/
    //---------------------------------------------------------------------------------------------------


    /*28 String 实现string的indexOf方法，注意“”的情况
            ##使用substring方法实现
     */
    /*35 array 二分 ,在一个有序数组里查一个数字，有则返回index，没有则返回可以插入的位置
            典型的二分搜索，就是最后没有要返回那个位置的情况，自己画图想想
     */
    /*46 这里数组是不重复的，求一个数组中元素所有可能排列的组合
            ##想法基本等同于穷举，但是最开始自己写的每次创建Arraylist很慢，要记得另一种方法
     */
    /*47 在上边46的基础上考虑了有可能会重复的情况
            ##记住怎么做
     */
    /*53 array 动态规划 数组中最大子数组和的大小
           ##记住怎么写，特别是temp那里 temp=Math.max(nums[i],nums[i]+temp)，这里就是如果temp小于0
           ## 更新为nums[i]更大的数（负数），否则temp是正数，那么就把它加上，因为接下来还有可能让他变得更大
     */
    /*54 array 顺时针绕圈打印数组
            ##在jianzhiOffer又写了一次，错了好几遍，4个循环中后两个循环要加入判断条件
     */
    /*58 string 判断一个string最后一个单词的长度，这个string有空格分割，如果没有最后一个字母，全是空格的情况返回0
            自己之前写出来过。思路是从后边来，然后如果遇到空格，就判断有没有记录长度，记录了几个长度的话，那几句说明可以到空格了，可以返回
            否则就一直往前走，直到遇到第一个不为空格的字符
     */
    /*61 linked list，把链表向右移动n位，12345 2 → 45123
            我自己的方法是先看链表长度，然后重新调整位置关系
     */
    /*66 array 一个数组代表一个数，然后+1，返回新数组
            ##从后边来，如果小于9，那么该位+1，然后直接返回就好了
            ## 如果刚好为9，那么进位，刚前边走，如果最高位还有1，那么就要创建一个新的数组了，然后第0位为1
     */
    /*67 Binary string,二进制计算相加，然后返回字符串
           (int)'1'并不是1，可以通过 '1'-'0'来获得值，还要记住Character.getNumericValue
     */
    /*69 二分 math,实现开方，返回正数部分就好了
            用二分法不断地判断
     */
    /*70 动态规划，n代表格数，可以走一步或者走两步，问到n总共有多少种走法
            解法就是走到n的方法为前一个格的方法（走一个到这里）+前两个格的方法（跳2格到这里）的方法之和
            ##然而递归和数组的方法都很慢，抄了下网上的方法
     */
    /*83 linked list 删除有序链表中重复的值
            竟然写错了几次。。
     */
    /*88 array ，把两个有序数组合并到第一个数组去
            想了想，从前边来要调整第一个数组，会很麻烦，所以要从后边去填充数组
     */
    /*92 linked list 在指定两个位置的范围内反转链表
            自己写的，是分两种情况，想了想就是起始位置为1和起始位置不为1的两种情况，因为会涉及前驱节点的问题
     */
    /*100 tree 判断两个树是否一样
            竟然也写错了几次，然后在这个题里边两个节点是否一样应该判断val值是否相等
     */
    /*101 tree 是不是对称树
            简而言之想到的是用递归，判断左右相等，左边的左边和右边的右边，左边的右边和右边的在左边
     */
    /*102 tree 按行输出每一行的节点值
            这一次通过queue写出来了，而不是还用原来的list，然后遍历list的方法
     */
    /*104 tree 树的最大路径长度
            很简单的递归 return 1+Math.max(func(root.left),func(root.right))
     */
    /*107 tree 按行输出每一行的节点，不过最后结果相比102要反过来
            就是把result.add(temp)改成result.add(0,temp)
     */
    /*108 tree 把一个有序的数组变为一个平衡的树
            把数组进行二分查找，每次取中间的，然后左边的节点的方位在左边取中间，右边的节点在右边去中间值，如此递归
     */
    /*110 tree 判断二叉树是否平衡
            ##没在用老方法，这里记住别人的方法是怎么一步到位的
     */
    /*111 tree  根到树叶节点的最小路径长度
            错了一次，要记得是到树叶，所以不能直接只用 return 1+Math.min()，因为可能根节点少个儿子节点
     */
    /*112 tree 判断“根到树叶”节点的总和有没有能刚好跟sum一样的
            错了一次，没有仔细看根到树叶这个条件，以为只要路径加上等于sum就好了。。
     */
    /*113 tree 同112，把所有跟到树叶等于sum的路径放到list里边
            第一种写法，出错了2次，慢一点写，这种写法肯定很慢
            ##学习下别人的写法
     */
    /*118 math array,杨辉三角形
            复习下杨辉三角形
     */
    /*119 math array
            同118复习下杨辉三角形
     */
    /*121 array 动态规划，股票最大收益，一个时间买，一个时间卖，数组中，两个数相减的最大值，负数算0
            就是找最小的位置点，大的话就要两者相减
     */
    /*122 array 动态规划，股票可以多次买卖
            首先 1 2 5 的情况，12 25 和15是一样的，说明只要高了就可以卖，小的话只更新坐标。
     */
    /*125 string array,判断一个字符串是不是回文类型，只看字符数字，大小写忽略，其他符号也忽略
            额。。感觉没什么好说的，就是复习下 a-z 97-122 A-Z 65-90 0-9 48-57
     */
    /*136 位运算，数组中每个元素都出现了2次，只有一个出现了一次，找到他
            ##一个数异或自己是0,0异或一个数是自己，所以一直异或下去，最后那个数就是单独的一个数
     */
    /*141 linked list，判断链表是否存在环
            通过快慢指针判断
     */
    /*147 linked list，使用插入排序给链表排序
            插入排序在数组中是一个index不断地往前比，但是在链表中不能往前，所以想法就是从头开始比，
     */
    /*148 linked list，要用nlogn的方法实现链表排序
            ##这里用的归并，①记住这里的快慢指针找链表一半的方法，
                           ②然后两个（有序）链表合并排序，然后不停地合并两个链表,又可以用合并两个有序链表的方法
     */
    /*155 stack ,自定义一个stack，额外实现一个getMin的方法
            1,通过现成的stack，然后每次push，如果新的值更小，那么要把老的值也也一起push一下，在push新值，这样pop的时候，如果pop的是最小值，那么再pop一下就是最小值了
            ##2，通过链表的方法值得一看
     */
    /*160 linked list，判断两个不循环链表的有没有交叠点
            1，判断长度，然后根据长度差来弄得不再写了
            ##2，网上的方法，各自往前走，如果遇到null，那么返回另一个链表的头，这样等于通过这种方法，长的走完第一次
            ##回到另一个链表头结点的时候，弥补了长度差，然后在一直走下去，判断什么时候两个指针指的相同
     */
    /*167 array 动态规划 二分，一个有序的twoSum，返回等于target的两个数组坐标，然后注意最后坐标要+1
            1从两边走动态规划，想加起来，如果小了，前边+1，大了，后边-1；
            ##2二分做法想一想，没复制下来
     */
    /*168 Math ，进制，把1-26转换成A-Z的输出，27就是AA
            ##进制类问题，首先1-26 应该转变成0-25，所以解题中 最开始的数要减去1，然后%26的值+‘A’代表的就是对应的字符
     */
    /*169 Array，找出数组中的占据一半或一半以上的数
            1，排序，然后中间的值。。。这个不太好
            2维持一个count，如果跟保存的数相同那么就++，否则--，如果小于0了，那么就更新保存的数，并把count置0
            因为主要元素是超过或者等于一半的数，那么这个主要元素肯定会使count非负
     */
    /*171 Math，168题目的反转，字母转数字
            不要使用s.tocharArray了，直接用s.charAt()
     */
    /*172 Math，判断n！的阶乘的结果末尾有多少个0
            首先肯定只有出现5*2的情况才会出现0，那么只要这种情况出现多少次就好了
            因为2的情况肯定比5多，那么就找5出现了多少次就好了，注意在25！的情况下，除以5有5个，但是还有一个5，所以就是这个数不停除以5的结果相加
     */
    /*189 array，把一个数组向右移动K位
            首先要用K%数组长度来判断到底移动几位
            然后采用在书上看的方法，如何翻转指定位置的数组
            然后就是想一想到底是在哪个位置翻转的
     */
    /*190 位运算，把一个32位无符号正数翻转过来
            ##同反转一个整数，熟悉下位运算<< >>，那么就是每次获得数的最后一位，然后左移，然后原来的数右移
     */
    /*191 位运算，判断一个无符号的整数有多少个1，比如3→11，那么他就有2个1
            那就不停地判断最后1位是不是1（&1），然后除以2的方式不行，因为他说了是无符号的数字，所以最高位是1的话就出了点问题
     */
    /*198 动态规划，数组全是非负数，然后不能取相邻格子的值，那么求取得的最大值
            最开始写了个递归，时间超了
            想了一会怎么用循环，维持temp1和temp2，分别表示上一个前两个格子位置的最大值和前一个格子的最大值
            那么每次进行比较，就是把当前坐标的值+temp1 和temp2进行比较，然后更新temp1，temp2
     */

    /*203 linked list，删除链表中含有指定值的节点
            尝试使用在头结点之前价格节点pre，然后pre.next=head, temp=pre的方法完成此题
     */
    /*204 math，找出小于数n的质数有多少个，复习下如何快速判断一个数是不是质数
            ##这里首先定义了一个n的数组，然后从第一个质数2开始，把他的倍数的数都认为不是质数
     */



}
